! function(t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.signalR = e() : t.signalR = e()
}(self, (function() {
    return (() => {
        "use strict";
        var t = {
            d: (e, o) => {
                for (var n in o) t.o(o, n) && !t.o(e, n) && Object.defineProperty(e, n, {
                    enumerable: !0,
                    get: o[n]
                })
            }
        };
        t.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (t) {
                if ("object" == typeof window) return window
            }
        }(), t.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), t.r = t => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            })
        };
        var e, o = {};
        t.r(o), t.d(o, {
            AbortError: () => s,
            DefaultHttpClient: () => R,
            HttpClient: () => u,
            HttpError: () => n,
            HttpResponse: () => g,
            HttpTransportType: () => U,
            HubConnection: () => W,
            HubConnectionBuilder: () => Y,
            HubConnectionState: () => N,
            JsonHubProtocol: () => Q,
            LogLevel: () => e,
            MessageType: () => A,
            NullLogger: () => d,
            Subject: () => j,
            TimeoutError: () => r,
            TransferFormat: () => q,
            VERSION: () => p
        });
        class n extends Error {
            constructor(t, e) {
                const o = new.target.prototype;
                super(`${t}: Status code '${e}'`), this.statusCode = e, this.__proto__ = o
            }
        }
        class r extends Error {
            constructor(t = "A timeout occurred.") {
                const e = new.target.prototype;
                super(t), this.__proto__ = e
            }
        }
        class s extends Error {
            constructor(t = "An abort occurred.") {
                const e = new.target.prototype;
                super(t), this.__proto__ = e
            }
        }
        class i extends Error {
            constructor(t, e) {
                const o = new.target.prototype;
                super(t), this.transport = e, this.errorType = "UnsupportedTransportError", this.__proto__ = o
            }
        }
        class c extends Error {
            constructor(t, e) {
                const o = new.target.prototype;
                super(t), this.transport = e, this.errorType = "DisabledTransportError", this.__proto__ = o
            }
        }
        class a extends Error {
            constructor(t, e) {
                const o = new.target.prototype;
                super(t), this.transport = e, this.errorType = "FailedToStartTransportError", this.__proto__ = o
            }
        }
        class l extends Error {
            constructor(t) {
                const e = new.target.prototype;
                super(t), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = e
            }
        }
        class h extends Error {
            constructor(t, e) {
                const o = new.target.prototype;
                super(t), this.innerErrors = e, this.__proto__ = o
            }
        }
        class g {
            constructor(t, e, o) {
                this.statusCode = t, this.statusText = e, this.content = o
            }
        }
        class u {
            get(t, e) {
                return this.send({
                    ...e,
                    method: "GET",
                    url: t
                })
            }
            post(t, e) {
                return this.send({
                    ...e,
                    method: "POST",
                    url: t
                })
            }
            delete(t, e) {
                return this.send({
                    ...e,
                    method: "DELETE",
                    url: t
                })
            }
            getCookieString(t) {
                return ""
            }
        }! function(t) {
            t[t.Trace = 0] = "Trace", t[t.Debug = 1] = "Debug", t[t.Information = 2] = "Information", t[t.Warning = 3] = "Warning", t[t.Error = 4] = "Error", t[t.Critical = 5] = "Critical", t[t.None = 6] = "None"
        }(e || (e = {}));
        class d {
            constructor() {}
            log(t, e) {}
        }
        d.instance = new d;
        const p = "6.0.7";
        class _ {
            static isRequired(t, e) {
                if (null == t) throw new Error(`The '${e}' argument is required.`)
            }
            static isNotEmpty(t, e) {
                if (!t || t.match(/^\s*$/)) throw new Error(`The '${e}' argument should not be empty.`)
            }
            static isIn(t, e, o) {
                if (!(t in e)) throw new Error(`Unknown ${o} value: ${t}.`)
            }
        }
        class f {
            static get isBrowser() {
                return "object" == typeof window && "object" == typeof window.document
            }
            static get isWebWorker() {
                return "object" == typeof self && "importScripts" in self
            }
            static get isReactNative() {
                return "object" == typeof window && void 0 === window.document
            }
            static get isNode() {
                return !this.isBrowser && !this.isWebWorker && !this.isReactNative
            }
        }

        function w(t, e) {
            let o = "";
            return m(t) ? (o = "Binary data of length " + t.byteLength, e && (o += `. Content: '${function(t){const e=new Uint8Array(t);let o="";return e.forEach(t=>{o+=`0x${t<16?"0":""}${t.toString(16)} `}),o.substr(0,o.length-1)}(t)}'`)) : "string" == typeof t && (o = "String data of length " + t.length, e && (o += `. Content: '${t}'`)), o
        }

        function m(t) {
            return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name)
        }
        async function b(t, o, n, r, s, i, c) {
            let a = {};
            if (s) {
                const t = await s();
                t && (a = {
                    Authorization: "Bearer " + t
                })
            }
            const [l, h] = S();
            a[l] = h, t.log(e.Trace, `(${o} transport) sending data. ${w(i,c.logMessageContent)}.`);
            const g = m(i) ? "arraybuffer" : "text",
                u = await n.post(r, {
                    content: i,
                    headers: {
                        ...a,
                        ...c.headers
                    },
                    responseType: g,
                    timeout: c.timeout,
                    withCredentials: c.withCredentials
                });
            t.log(e.Trace, `(${o} transport) request complete. Response status: ${u.statusCode}.`)
        }
        class y {
            constructor(t, e) {
                this._subject = t, this._observer = e
            }
            dispose() {
                const t = this._subject.observers.indexOf(this._observer);
                t > -1 && this._subject.observers.splice(t, 1), 0 === this._subject.observers.length && this._subject.cancelCallback && this._subject.cancelCallback().catch(t => {})
            }
        }
        class v {
            constructor(t) {
                this._minLevel = t, this.out = console
            }
            log(t, o) {
                if (t >= this._minLevel) {
                    const n = `[${(new Date).toISOString()}] ${e[t]}: ${o}`;
                    switch (t) {
                        case e.Critical:
                        case e.Error:
                            this.out.error(n);
                            break;
                        case e.Warning:
                            this.out.warn(n);
                            break;
                        case e.Information:
                            this.out.info(n);
                            break;
                        default:
                            this.out.log(n)
                    }
                }
            }
        }

        function S() {
            let t = "X-SignalR-User-Agent";
            return f.isNode && (t = "User-Agent"), [t, C(p, E(), T(), k())]
        }

        function C(t, e, o, n) {
            let r = "Microsoft SignalR/";
            const s = t.split(".");
            return r += `${s[0]}.${s[1]}`, r += ` (${t}; `, r += e && "" !== e ? e + "; " : "Unknown OS; ", r += "" + o, r += n ? "; " + n : "; Unknown Runtime Version", r += ")", r
        }

        function E() {
            if (!f.isNode) return "";
            switch (process.platform) {
                case "win32":
                    return "Windows NT";
                case "darwin":
                    return "macOS";
                case "linux":
                    return "Linux";
                default:
                    return process.platform
            }
        }

        function k() {
            if (f.isNode) return process.versions.node
        }

        function T() {
            return f.isNode ? "NodeJS" : "Browser"
        }

        function I(t) {
            return t.stack ? t.stack : t.message ? t.message : "" + t
        }
        class P extends u {
            constructor(e) {
                if (super(), this._logger = e, "undefined" == typeof fetch) {
                    const t = require;
                    this._jar = new(t("tough-cookie").CookieJar), this._fetchType = t("node-fetch"), this._fetchType = t("fetch-cookie")(this._fetchType, this._jar)
                } else this._fetchType = fetch.bind(function() {
                    if ("undefined" != typeof globalThis) return globalThis;
                    if ("undefined" != typeof self) return self;
                    if ("undefined" != typeof window) return window;
                    if (void 0 !== t.g) return t.g;
                    throw new Error("could not find global")
                }());
                if ("undefined" == typeof AbortController) {
                    const t = require;
                    this._abortControllerType = t("abort-controller")
                } else this._abortControllerType = AbortController
            }
            async send(t) {
                if (t.abortSignal && t.abortSignal.aborted) throw new s;
                if (!t.method) throw new Error("No method defined.");
                if (!t.url) throw new Error("No url defined.");
                const o = new this._abortControllerType;
                let i;
                t.abortSignal && (t.abortSignal.onabort = () => {
                    o.abort(), i = new s
                });
                let c, a = null;
                if (t.timeout) {
                    const n = t.timeout;
                    a = setTimeout(() => {
                        o.abort(), this._logger.log(e.Warning, "Timeout from HTTP request."), i = new r
                    }, n)
                }
                try {
                    c = await this._fetchType(t.url, {
                        body: t.content,
                        cache: "no-cache",
                        credentials: !0 === t.withCredentials ? "include" : "same-origin",
                        headers: {
                            "Content-Type": "text/plain;charset=UTF-8",
                            "X-Requested-With": "XMLHttpRequest",
                            ...t.headers
                        },
                        method: t.method,
                        mode: "cors",
                        redirect: "follow",
                        signal: o.signal
                    })
                } catch (t) {
                    if (i) throw i;
                    throw this._logger.log(e.Warning, `Error from HTTP request. ${t}.`), t
                } finally {
                    a && clearTimeout(a), t.abortSignal && (t.abortSignal.onabort = null)
                }
                if (!c.ok) {
                    const t = await D(c, "text");
                    throw new n(t || c.statusText, c.status)
                }
                const l = D(c, t.responseType),
                    h = await l;
                return new g(c.status, c.statusText, h)
            }
            getCookieString(t) {
                let e = "";
                return f.isNode && this._jar && this._jar.getCookies(t, (t, o) => e = o.join("; ")), e
            }
        }

        function D(t, e) {
            let o;
            switch (e) {
                case "arraybuffer":
                    o = t.arrayBuffer();
                    break;
                case "text":
                    o = t.text();
                    break;
                case "blob":
                case "document":
                case "json":
                    throw new Error(e + " is not supported.");
                default:
                    o = t.text()
            }
            return o
        }
        class $ extends u {
            constructor(t) {
                super(), this._logger = t
            }
            send(t) {
                return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new s) : t.method ? t.url ? new Promise((o, i) => {
                    const c = new XMLHttpRequest;
                    c.open(t.method, t.url, !0), c.withCredentials = void 0 === t.withCredentials || t.withCredentials, c.setRequestHeader("X-Requested-With", "XMLHttpRequest"), c.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
                    const a = t.headers;
                    a && Object.keys(a).forEach(t => {
                        c.setRequestHeader(t, a[t])
                    }), t.responseType && (c.responseType = t.responseType), t.abortSignal && (t.abortSignal.onabort = () => {
                        c.abort(), i(new s)
                    }), t.timeout && (c.timeout = t.timeout), c.onload = () => {
                        t.abortSignal && (t.abortSignal.onabort = null), c.status >= 200 && c.status < 300 ? o(new g(c.status, c.statusText, c.response || c.responseText)) : i(new n(c.response || c.responseText || c.statusText, c.status))
                    }, c.onerror = () => {
                        this._logger.log(e.Warning, `Error from HTTP request. ${c.status}: ${c.statusText}.`), i(new n(c.statusText, c.status))
                    }, c.ontimeout = () => {
                        this._logger.log(e.Warning, "Timeout from HTTP request."), i(new r)
                    }, c.send(t.content || "")
                }) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."))
            }
        }
        class R extends u {
            constructor(t) {
                if (super(), "undefined" != typeof fetch || f.isNode) this._httpClient = new P(t);
                else {
                    if ("undefined" == typeof XMLHttpRequest) throw new Error("No usable HttpClient found.");
                    this._httpClient = new $(t)
                }
            }
            send(t) {
                return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new s) : t.method ? t.url ? this._httpClient.send(t) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined."))
            }
            getCookieString(t) {
                return this._httpClient.getCookieString(t)
            }
        }
        class x {
            static write(t) {
                return `${t}${x.RecordSeparator}`
            }
            static parse(t) {
                if (t[t.length - 1] !== x.RecordSeparator) throw new Error("Message is incomplete.");
                const e = t.split(x.RecordSeparator);
                return e.pop(), e
            }
        }
        x.RecordSeparatorCode = 30, x.RecordSeparator = String.fromCharCode(x.RecordSeparatorCode);
        class H {
            writeHandshakeRequest(t) {
                return x.write(JSON.stringify(t))
            }
            parseHandshakeResponse(t) {
                let e, o;
                if (m(t)) {
                    const n = new Uint8Array(t),
                        r = n.indexOf(x.RecordSeparatorCode);
                    if (-1 === r) throw new Error("Message is incomplete.");
                    const s = r + 1;
                    e = String.fromCharCode.apply(null, Array.prototype.slice.call(n.slice(0, s))), o = n.byteLength > s ? n.slice(s).buffer : null
                } else {
                    const n = t,
                        r = n.indexOf(x.RecordSeparator);
                    if (-1 === r) throw new Error("Message is incomplete.");
                    const s = r + 1;
                    e = n.substring(0, s), o = n.length > s ? n.substring(s) : null
                }
                const n = x.parse(e),
                    r = JSON.parse(n[0]);
                if (r.type) throw new Error("Expected a handshake response from the server.");
                return [o, r]
            }
        }
        var A;
        ! function(t) {
            t[t.Invocation = 1] = "Invocation", t[t.StreamItem = 2] = "StreamItem", t[t.Completion = 3] = "Completion", t[t.StreamInvocation = 4] = "StreamInvocation", t[t.CancelInvocation = 5] = "CancelInvocation", t[t.Ping = 6] = "Ping", t[t.Close = 7] = "Close"
        }(A || (A = {}));
        class j {
            constructor() {
                this.observers = []
            }
            next(t) {
                for (const e of this.observers) e.next(t)
            }
            error(t) {
                for (const e of this.observers) e.error && e.error(t)
            }
            complete() {
                for (const t of this.observers) t.complete && t.complete()
            }
            subscribe(t) {
                return this.observers.push(t), new y(this, t)
            }
        }
        var N;
        ! function(t) {
            t.Disconnected = "Disconnected", t.Connecting = "Connecting", t.Connected = "Connected", t.Disconnecting = "Disconnecting", t.Reconnecting = "Reconnecting"
        }(N || (N = {}));
        class W {
            constructor(t, o, n, r) {
                this._nextKeepAlive = 0, this._freezeEventListener = () => {
                    this._logger.log(e.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")
                }, _.isRequired(t, "connection"), _.isRequired(o, "logger"), _.isRequired(n, "protocol"), this.serverTimeoutInMilliseconds = 3e4, this.keepAliveIntervalInMilliseconds = 15e3, this._logger = o, this._protocol = n, this.connection = t, this._reconnectPolicy = r, this._handshakeProtocol = new H, this.connection.onreceive = t => this._processIncomingData(t), this.connection.onclose = t => this._connectionClosed(t), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = N.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({
                    type: A.Ping
                })
            }
            static create(t, e, o, n) {
                return new W(t, e, o, n)
            }
            get state() {
                return this._connectionState
            }
            get connectionId() {
                return this.connection && this.connection.connectionId || null
            }
            get baseUrl() {
                return this.connection.baseUrl || ""
            }
            set baseUrl(t) {
                if (this._connectionState !== N.Disconnected && this._connectionState !== N.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
                if (!t) throw new Error("The HubConnection url must be a valid url.");
                this.connection.baseUrl = t
            }
            start() {
                return this._startPromise = this._startWithStateTransitions(), this._startPromise
            }
            async _startWithStateTransitions() {
                if (this._connectionState !== N.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));
                this._connectionState = N.Connecting, this._logger.log(e.Debug, "Starting HubConnection.");
                try {
                    await this._startInternal(), f.isBrowser && window.document.addEventListener("freeze", this._freezeEventListener), this._connectionState = N.Connected, this._connectionStarted = !0, this._logger.log(e.Debug, "HubConnection connected successfully.")
                } catch (t) {
                    return this._connectionState = N.Disconnected, this._logger.log(e.Debug, `HubConnection failed to start successfully because of error '${t}'.`), Promise.reject(t)
                }
            }
            async _startInternal() {
                this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1;
                const t = new Promise((t, e) => {
                    this._handshakeResolver = t, this._handshakeRejecter = e
                });
                await this.connection.start(this._protocol.transferFormat);
                try {
                    const o = {
                        protocol: this._protocol.name,
                        version: this._protocol.version
                    };
                    if (this._logger.log(e.Debug, "Sending handshake request."), await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(o)), this._logger.log(e.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), await t, this._stopDuringStartError) throw this._stopDuringStartError
                } catch (t) {
                    throw this._logger.log(e.Debug, `Hub handshake failed with error '${t}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), await this.connection.stop(t), t
                }
            }
            async stop() {
                const t = this._startPromise;
                this._stopPromise = this._stopInternal(), await this._stopPromise;
                try {
                    await t
                } catch (t) {}
            }
            _stopInternal(t) {
                return this._connectionState === N.Disconnected ? (this._logger.log(e.Debug, `Call to HubConnection.stop(${t}) ignored because it is already in the disconnected state.`), Promise.resolve()) : this._connectionState === N.Disconnecting ? (this._logger.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = N.Disconnecting, this._logger.log(e.Debug, "Stopping HubConnection."), this._reconnectDelayHandle ? (this._logger.log(e.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = t || new Error("The connection was stopped before the hub handshake could complete."), this.connection.stop(t)))
            }
            stream(t, ...e) {
                const [o, n] = this._replaceStreamingParams(e), r = this._createStreamInvocation(t, e, n);
                let s;
                const i = new j;
                return i.cancelCallback = () => {
                    const t = this._createCancelInvocation(r.invocationId);
                    return delete this._callbacks[r.invocationId], s.then(() => this._sendWithProtocol(t))
                }, this._callbacks[r.invocationId] = (t, e) => {
                    e ? i.error(e) : t && (t.type === A.Completion ? t.error ? i.error(new Error(t.error)) : i.complete() : i.next(t.item))
                }, s = this._sendWithProtocol(r).catch(t => {
                    i.error(t), delete this._callbacks[r.invocationId]
                }), this._launchStreams(o, s), i
            }
            _sendMessage(t) {
                return this._resetKeepAliveInterval(), this.connection.send(t)
            }
            _sendWithProtocol(t) {
                return this._sendMessage(this._protocol.writeMessage(t))
            }
            send(t, ...e) {
                const [o, n] = this._replaceStreamingParams(e), r = this._sendWithProtocol(this._createInvocation(t, e, !0, n));
                return this._launchStreams(o, r), r
            }
            invoke(t, ...e) {
                const [o, n] = this._replaceStreamingParams(e), r = this._createInvocation(t, e, !1, n);
                return new Promise((t, e) => {
                    this._callbacks[r.invocationId] = (o, n) => {
                        n ? e(n) : o && (o.type === A.Completion ? o.error ? e(new Error(o.error)) : t(o.result) : e(new Error("Unexpected message type: " + o.type)))
                    };
                    const n = this._sendWithProtocol(r).catch(t => {
                        e(t), delete this._callbacks[r.invocationId]
                    });
                    this._launchStreams(o, n)
                })
            }
            on(t, e) {
                t && e && (t = t.toLowerCase(), this._methods[t] || (this._methods[t] = []), -1 === this._methods[t].indexOf(e) && this._methods[t].push(e))
            }
            off(t, e) {
                if (!t) return;
                t = t.toLowerCase();
                const o = this._methods[t];
                if (o)
                    if (e) {
                        const n = o.indexOf(e); - 1 !== n && (o.splice(n, 1), 0 === o.length && delete this._methods[t])
                    } else delete this._methods[t]
            }
            onclose(t) {
                t && this._closedCallbacks.push(t)
            }
            onreconnecting(t) {
                t && this._reconnectingCallbacks.push(t)
            }
            onreconnected(t) {
                t && this._reconnectedCallbacks.push(t)
            }
            _processIncomingData(t) {
                if (this._cleanupTimeout(), this._receivedHandshakeResponse || (t = this._processHandshakeResponse(t), this._receivedHandshakeResponse = !0), t) {
                    const o = this._protocol.parseMessages(t, this._logger);
                    for (const t of o) switch (t.type) {
                        case A.Invocation:
                            this._invokeClientMethod(t);
                            break;
                        case A.StreamItem:
                        case A.Completion: {
                            const o = this._callbacks[t.invocationId];
                            if (o) {
                                t.type === A.Completion && delete this._callbacks[t.invocationId];
                                try {
                                    o(t)
                                } catch (t) {
                                    this._logger.log(e.Error, "Stream callback threw error: " + I(t))
                                }
                            }
                            break
                        }
                        case A.Ping:
                            break;
                        case A.Close: {
                            this._logger.log(e.Information, "Close message received from server.");
                            const o = t.error ? new Error("Server returned an error on close: " + t.error) : void 0;
                            !0 === t.allowReconnect ? this.connection.stop(o) : this._stopPromise = this._stopInternal(o);
                            break
                        }
                        default:
                            this._logger.log(e.Warning, `Invalid message type: ${t.type}.`)
                    }
                }
                this._resetTimeoutPeriod()
            }
            _processHandshakeResponse(t) {
                let o, n;
                try {
                    [n, o] = this._handshakeProtocol.parseHandshakeResponse(t)
                } catch (t) {
                    const o = "Error parsing handshake response: " + t;
                    this._logger.log(e.Error, o);
                    const n = new Error(o);
                    throw this._handshakeRejecter(n), n
                }
                if (o.error) {
                    const t = "Server returned handshake error: " + o.error;
                    this._logger.log(e.Error, t);
                    const n = new Error(t);
                    throw this._handshakeRejecter(n), n
                }
                return this._logger.log(e.Debug, "Server handshake complete."), this._handshakeResolver(), n
            }
            _resetKeepAliveInterval() {
                this.connection.features.inherentKeepAlive || (this._nextKeepAlive = (new Date).getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer())
            }
            _resetTimeoutPeriod() {
                if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds), void 0 !== this._pingServerHandle))) {
                    let t = this._nextKeepAlive - (new Date).getTime();
                    t < 0 && (t = 0), this._pingServerHandle = setTimeout(async () => {
                        if (this._connectionState === N.Connected) try {
                            await this._sendMessage(this._cachedPingMessage)
                        } catch {
                            this._cleanupPingTimer()
                        }
                    }, t)
                }
            }
            serverTimeout() {
                this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))
            }
            _invokeClientMethod(t) {
                const o = this._methods[t.target.toLowerCase()];
                if (o) {
                    try {
                        o.forEach(e => e.apply(this, t.arguments))
                    } catch (o) {
                        this._logger.log(e.Error, `A callback for the method ${t.target.toLowerCase()} threw error '${o}'.`)
                    }
                    if (t.invocationId) {
                        const t = "Server requested a response, which is not supported in this version of the client.";
                        this._logger.log(e.Error, t), this._stopPromise = this._stopInternal(new Error(t))
                    }
                } else this._logger.log(e.Warning, `No client method with the name '${t.target}' found.`)
            }
            _connectionClosed(t) {
                this._logger.log(e.Debug, `HubConnection.connectionClosed(${t}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || t || new Error("The underlying connection was closed before the hub handshake could complete."), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(t || new Error("Invocation canceled due to the underlying connection being closed.")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === N.Disconnecting ? this._completeClose(t) : this._connectionState === N.Connected && this._reconnectPolicy ? this._reconnect(t) : this._connectionState === N.Connected && this._completeClose(t)
            }
            _completeClose(t) {
                if (this._connectionStarted) {
                    this._connectionState = N.Disconnected, this._connectionStarted = !1, f.isBrowser && window.document.removeEventListener("freeze", this._freezeEventListener);
                    try {
                        this._closedCallbacks.forEach(e => e.apply(this, [t]))
                    } catch (o) {
                        this._logger.log(e.Error, `An onclose callback called with error '${t}' threw error '${o}'.`)
                    }
                }
            }
            async _reconnect(t) {
                const o = Date.now();
                let n = 0,
                    r = void 0 !== t ? t : new Error("Attempting to reconnect due to a unknown error."),
                    s = this._getNextRetryDelay(n++, 0, r);
                if (null === s) return this._logger.log(e.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this._completeClose(t);
                if (this._connectionState = N.Reconnecting, t ? this._logger.log(e.Information, `Connection reconnecting because of error '${t}'.`) : this._logger.log(e.Information, "Connection reconnecting."), 0 !== this._reconnectingCallbacks.length) {
                    try {
                        this._reconnectingCallbacks.forEach(e => e.apply(this, [t]))
                    } catch (o) {
                        this._logger.log(e.Error, `An onreconnecting callback called with error '${t}' threw error '${o}'.`)
                    }
                    if (this._connectionState !== N.Reconnecting) return void this._logger.log(e.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")
                }
                for (; null !== s;) {
                    if (this._logger.log(e.Information, `Reconnect attempt number ${n} will start in ${s} ms.`), await new Promise(t => {
                            this._reconnectDelayHandle = setTimeout(t, s)
                        }), this._reconnectDelayHandle = void 0, this._connectionState !== N.Reconnecting) return void this._logger.log(e.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                    try {
                        if (await this._startInternal(), this._connectionState = N.Connected, this._logger.log(e.Information, "HubConnection reconnected successfully."), 0 !== this._reconnectedCallbacks.length) try {
                            this._reconnectedCallbacks.forEach(t => t.apply(this, [this.connection.connectionId]))
                        } catch (t) {
                            this._logger.log(e.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${t}'.`)
                        }
                        return
                    } catch (t) {
                        if (this._logger.log(e.Information, `Reconnect attempt failed because of error '${t}'.`), this._connectionState !== N.Reconnecting) return this._logger.log(e.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void(this._connectionState === N.Disconnecting && this._completeClose());
                        r = t instanceof Error ? t : new Error(t.toString()), s = this._getNextRetryDelay(n++, Date.now() - o, r)
                    }
                }
                this._logger.log(e.Information, `Reconnect retries have been exhausted after ${Date.now()-o} ms and ${n} failed attempts. Connection disconnecting.`), this._completeClose()
            }
            _getNextRetryDelay(t, o, n) {
                try {
                    return this._reconnectPolicy.nextRetryDelayInMilliseconds({
                        elapsedMilliseconds: o,
                        previousRetryCount: t,
                        retryReason: n
                    })
                } catch (n) {
                    return this._logger.log(e.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${t}, ${o}) threw error '${n}'.`), null
                }
            }
            _cancelCallbacksWithError(t) {
                const o = this._callbacks;
                this._callbacks = {}, Object.keys(o).forEach(n => {
                    const r = o[n];
                    try {
                        r(null, t)
                    } catch (o) {
                        this._logger.log(e.Error, `Stream 'error' callback called with '${t}' threw error: ${I(o)}`)
                    }
                })
            }
            _cleanupPingTimer() {
                this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0)
            }
            _cleanupTimeout() {
                this._timeoutHandle && clearTimeout(this._timeoutHandle)
            }
            _createInvocation(t, e, o, n) {
                if (o) return 0 !== n.length ? {
                    arguments: e,
                    streamIds: n,
                    target: t,
                    type: A.Invocation
                } : {
                    arguments: e,
                    target: t,
                    type: A.Invocation
                };
                {
                    const o = this._invocationId;
                    return this._invocationId++, 0 !== n.length ? {
                        arguments: e,
                        invocationId: o.toString(),
                        streamIds: n,
                        target: t,
                        type: A.Invocation
                    } : {
                        arguments: e,
                        invocationId: o.toString(),
                        target: t,
                        type: A.Invocation
                    }
                }
            }
            _launchStreams(t, e) {
                if (0 !== t.length) {
                    e || (e = Promise.resolve());
                    for (const o in t) t[o].subscribe({
                        complete: () => {
                            e = e.then(() => this._sendWithProtocol(this._createCompletionMessage(o)))
                        },
                        error: t => {
                            let n;
                            n = t instanceof Error ? t.message : t && t.toString ? t.toString() : "Unknown error", e = e.then(() => this._sendWithProtocol(this._createCompletionMessage(o, n)))
                        },
                        next: t => {
                            e = e.then(() => this._sendWithProtocol(this._createStreamItemMessage(o, t)))
                        }
                    })
                }
            }
            _replaceStreamingParams(t) {
                const e = [],
                    o = [];
                for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    if (this._isObservable(r)) {
                        const s = this._invocationId;
                        this._invocationId++, e[s] = r, o.push(s.toString()), t.splice(n, 1)
                    }
                }
                return [e, o]
            }
            _isObservable(t) {
                return t && t.subscribe && "function" == typeof t.subscribe
            }
            _createStreamInvocation(t, e, o) {
                const n = this._invocationId;
                return this._invocationId++, 0 !== o.length ? {
                    arguments: e,
                    invocationId: n.toString(),
                    streamIds: o,
                    target: t,
                    type: A.StreamInvocation
                } : {
                    arguments: e,
                    invocationId: n.toString(),
                    target: t,
                    type: A.StreamInvocation
                }
            }
            _createCancelInvocation(t) {
                return {
                    invocationId: t,
                    type: A.CancelInvocation
                }
            }
            _createStreamItemMessage(t, e) {
                return {
                    invocationId: t,
                    item: e,
                    type: A.StreamItem
                }
            }
            _createCompletionMessage(t, e, o) {
                return e ? {
                    error: e,
                    invocationId: t,
                    type: A.Completion
                } : {
                    invocationId: t,
                    result: o,
                    type: A.Completion
                }
            }
        }
        const M = [0, 2e3, 1e4, 3e4, null];
        class L {
            constructor(t) {
                this._retryDelays = void 0 !== t ? [...t, null] : M
            }
            nextRetryDelayInMilliseconds(t) {
                return this._retryDelays[t.previousRetryCount]
            }
        }
        class O {}
        var U, q;
        O.Authorization = "Authorization", O.Cookie = "Cookie",
            function(t) {
                t[t.None = 0] = "None", t[t.WebSockets = 1] = "WebSockets", t[t.ServerSentEvents = 2] = "ServerSentEvents", t[t.LongPolling = 4] = "LongPolling"
            }(U || (U = {})),
            function(t) {
                t[t.Text = 1] = "Text", t[t.Binary = 2] = "Binary"
            }(q || (q = {}));
        class F {
            constructor() {
                this._isAborted = !1, this.onabort = null
            }
            abort() {
                this._isAborted || (this._isAborted = !0, this.onabort && this.onabort())
            }
            get signal() {
                return this
            }
            get aborted() {
                return this._isAborted
            }
        }
        class B {
            constructor(t, e, o, n) {
                this._httpClient = t, this._accessTokenFactory = e, this._logger = o, this._pollAbort = new F, this._options = n, this._running = !1, this.onreceive = null, this.onclose = null
            }
            get pollAborted() {
                return this._pollAbort.aborted
            }
            async connect(t, o) {
                if (_.isRequired(t, "url"), _.isRequired(o, "transferFormat"), _.isIn(o, q, "transferFormat"), this._url = t, this._logger.log(e.Trace, "(LongPolling transport) Connecting."), o === q.Binary && "undefined" != typeof XMLHttpRequest && "string" != typeof(new XMLHttpRequest).responseType) throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                const [r, s] = S(), i = {
                    [r]: s,
                    ...this._options.headers
                }, c = {
                    abortSignal: this._pollAbort.signal,
                    headers: i,
                    timeout: 1e5,
                    withCredentials: this._options.withCredentials
                };
                o === q.Binary && (c.responseType = "arraybuffer");
                const a = await this._getAccessToken();
                this._updateHeaderToken(c, a);
                const l = `${t}&_=${Date.now()}`;
                this._logger.log(e.Trace, `(LongPolling transport) polling: ${l}.`);
                const h = await this._httpClient.get(l, c);
                200 !== h.statusCode ? (this._logger.log(e.Error, `(LongPolling transport) Unexpected response code: ${h.statusCode}.`), this._closeError = new n(h.statusText || "", h.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, c)
            }
            async _getAccessToken() {
                return this._accessTokenFactory ? await this._accessTokenFactory() : null
            }
            _updateHeaderToken(t, e) {
                t.headers || (t.headers = {}), e ? t.headers[O.Authorization] = "Bearer " + e : t.headers[O.Authorization] && delete t.headers[O.Authorization]
            }
            async _poll(t, o) {
                try {
                    for (; this._running;) {
                        const s = await this._getAccessToken();
                        this._updateHeaderToken(o, s);
                        try {
                            const r = `${t}&_=${Date.now()}`;
                            this._logger.log(e.Trace, `(LongPolling transport) polling: ${r}.`);
                            const s = await this._httpClient.get(r, o);
                            204 === s.statusCode ? (this._logger.log(e.Information, "(LongPolling transport) Poll terminated by server."), this._running = !1) : 200 !== s.statusCode ? (this._logger.log(e.Error, `(LongPolling transport) Unexpected response code: ${s.statusCode}.`), this._closeError = new n(s.statusText || "", s.statusCode), this._running = !1) : s.content ? (this._logger.log(e.Trace, `(LongPolling transport) data received. ${w(s.content,this._options.logMessageContent)}.`), this.onreceive && this.onreceive(s.content)) : this._logger.log(e.Trace, "(LongPolling transport) Poll timed out, reissuing.")
                        } catch (t) {
                            this._running ? t instanceof r ? this._logger.log(e.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this._closeError = t, this._running = !1) : this._logger.log(e.Trace, "(LongPolling transport) Poll errored after shutdown: " + t.message)
                        }
                    }
                } finally {
                    this._logger.log(e.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this._raiseOnClose()
                }
            }
            async send(t) {
                return this._running ? b(this._logger, "LongPolling", this._httpClient, this._url, this._accessTokenFactory, t, this._options) : Promise.reject(new Error("Cannot send until the transport is connected"))
            }
            async stop() {
                this._logger.log(e.Trace, "(LongPolling transport) Stopping polling."), this._running = !1, this._pollAbort.abort();
                try {
                    await this._receiving, this._logger.log(e.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);
                    const t = {},
                        [o, n] = S();
                    t[o] = n;
                    const r = {
                            headers: {
                                ...t,
                                ...this._options.headers
                            },
                            timeout: this._options.timeout,
                            withCredentials: this._options.withCredentials
                        },
                        s = await this._getAccessToken();
                    this._updateHeaderToken(r, s), await this._httpClient.delete(this._url, r), this._logger.log(e.Trace, "(LongPolling transport) DELETE request sent.")
                } finally {
                    this._logger.log(e.Trace, "(LongPolling transport) Stop finished."), this._raiseOnClose()
                }
            }
            _raiseOnClose() {
                if (this.onclose) {
                    let t = "(LongPolling transport) Firing onclose event.";
                    this._closeError && (t += " Error: " + this._closeError), this._logger.log(e.Trace, t), this.onclose(this._closeError)
                }
            }
        }
        class z {
            constructor(t, e, o, n) {
                this._httpClient = t, this._accessTokenFactory = e, this._logger = o, this._options = n, this.onreceive = null, this.onclose = null
            }
            async connect(t, o) {
                if (_.isRequired(t, "url"), _.isRequired(o, "transferFormat"), _.isIn(o, q, "transferFormat"), this._logger.log(e.Trace, "(SSE transport) Connecting."), this._url = t, this._accessTokenFactory) {
                    const e = await this._accessTokenFactory();
                    e && (t += (t.indexOf("?") < 0 ? "?" : "&") + "access_token=" + encodeURIComponent(e))
                }
                return new Promise((n, r) => {
                    let s, i = !1;
                    if (o === q.Text) {
                        if (f.isBrowser || f.isWebWorker) s = new this._options.EventSource(t, {
                            withCredentials: this._options.withCredentials
                        });
                        else {
                            const e = this._httpClient.getCookieString(t),
                                o = {};
                            o.Cookie = e;
                            const [n, r] = S();
                            o[n] = r, s = new this._options.EventSource(t, {
                                withCredentials: this._options.withCredentials,
                                headers: {
                                    ...o,
                                    ...this._options.headers
                                }
                            })
                        }
                        try {
                            s.onmessage = t => {
                                if (this.onreceive) try {
                                    this._logger.log(e.Trace, `(SSE transport) data received. ${w(t.data,this._options.logMessageContent)}.`), this.onreceive(t.data)
                                } catch (t) {
                                    return void this._close(t)
                                }
                            }, s.onerror = t => {
                                i ? this._close() : r(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))
                            }, s.onopen = () => {
                                this._logger.log(e.Information, "SSE connected to " + this._url), this._eventSource = s, i = !0, n()
                            }
                        } catch (t) {
                            return void r(t)
                        }
                    } else r(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"))
                })
            }
            async send(t) {
                return this._eventSource ? b(this._logger, "SSE", this._httpClient, this._url, this._accessTokenFactory, t, this._options) : Promise.reject(new Error("Cannot send until the transport is connected"))
            }
            stop() {
                return this._close(), Promise.resolve()
            }
            _close(t) {
                this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(t))
            }
        }
        class X {
            constructor(t, e, o, n, r, s) {
                this._logger = o, this._accessTokenFactory = e, this._logMessageContent = n, this._webSocketConstructor = r, this._httpClient = t, this.onreceive = null, this.onclose = null, this._headers = s
            }
            async connect(t, o) {
                if (_.isRequired(t, "url"), _.isRequired(o, "transferFormat"), _.isIn(o, q, "transferFormat"), this._logger.log(e.Trace, "(WebSockets transport) Connecting."), this._accessTokenFactory) {
                    const e = await this._accessTokenFactory();
                    e && (t += (t.indexOf("?") < 0 ? "?" : "&") + "access_token=" + encodeURIComponent(e))
                }
                return new Promise((n, r) => {
                    let s;
                    t = t.replace(/^http/, "ws");
                    const i = this._httpClient.getCookieString(t);
                    let c = !1;
                    if (f.isNode) {
                        const e = {},
                            [o, n] = S();
                        e[o] = n, i && (e[O.Cookie] = "" + i), s = new this._webSocketConstructor(t, void 0, {
                            headers: {
                                ...e,
                                ...this._headers
                            }
                        })
                    }
                    s || (s = new this._webSocketConstructor(t)), o === q.Binary && (s.binaryType = "arraybuffer"), s.onopen = o => {
                        this._logger.log(e.Information, `WebSocket connected to ${t}.`), this._webSocket = s, c = !0, n()
                    }, s.onerror = t => {
                        let o = null;
                        o = "undefined" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : "There was an error with the transport", this._logger.log(e.Information, `(WebSockets transport) ${o}.`)
                    }, s.onmessage = t => {
                        if (this._logger.log(e.Trace, `(WebSockets transport) data received. ${w(t.data,this._logMessageContent)}.`), this.onreceive) try {
                            this.onreceive(t.data)
                        } catch (t) {
                            return void this._close(t)
                        }
                    }, s.onclose = t => {
                        if (c) this._close(t);
                        else {
                            let e = null;
                            e = "undefined" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", r(new Error(e))
                        }
                    }
                })
            }
            send(t) {
                return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(e.Trace, `(WebSockets transport) sending data. ${w(t,this._logMessageContent)}.`), this._webSocket.send(t), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state")
            }
            stop() {
                return this._webSocket && this._close(void 0), Promise.resolve()
            }
            _close(t) {
                this._webSocket && (this._webSocket.onclose = () => {}, this._webSocket.onmessage = () => {}, this._webSocket.onerror = () => {}, this._webSocket.close(), this._webSocket = void 0), this._logger.log(e.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this._isCloseEvent(t) || !1 !== t.wasClean && 1e3 === t.code ? t instanceof Error ? this.onclose(t) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${t.code} (${t.reason||"no reason given"}).`)))
            }
            _isCloseEvent(t) {
                return t && "boolean" == typeof t.wasClean && "number" == typeof t.code
            }
        }
        class J {
            constructor(t, o = {}) {
                var n;
                if (this._stopPromiseResolver = () => {}, this.features = {}, this._negotiateVersion = 1, _.isRequired(t, "url"), this._logger = void 0 === (n = o.logger) ? new v(e.Information) : null === n ? d.instance : void 0 !== n.log ? n : new v(n), this.baseUrl = this._resolveUrl(t), (o = o || {}).logMessageContent = void 0 !== o.logMessageContent && o.logMessageContent, "boolean" != typeof o.withCredentials && void 0 !== o.withCredentials) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
                o.withCredentials = void 0 === o.withCredentials || o.withCredentials, o.timeout = void 0 === o.timeout ? 1e5 : o.timeout;
                let r = null,
                    s = null;
                if (f.isNode) {
                    const t = require;
                    r = t("ws"), s = t("eventsource")
                }
                f.isNode || "undefined" == typeof WebSocket || o.WebSocket ? f.isNode && !o.WebSocket && r && (o.WebSocket = r) : o.WebSocket = WebSocket, f.isNode || "undefined" == typeof EventSource || o.EventSource ? f.isNode && !o.EventSource && void 0 !== s && (o.EventSource = s) : o.EventSource = EventSource, this._httpClient = o.httpClient || new R(this._logger), this._connectionState = "Disconnected", this._connectionStarted = !1, this._options = o, this.onreceive = null, this.onclose = null
            }
            async start(t) {
                if (t = t || q.Binary, _.isIn(t, q, "transferFormat"), this._logger.log(e.Debug, `Starting connection with transfer format '${q[t]}'.`), "Disconnected" !== this._connectionState) return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));
                if (this._connectionState = "Connecting", this._startInternalPromise = this._startInternal(t), await this._startInternalPromise, "Disconnecting" === this._connectionState) {
                    const t = "Failed to start the HttpConnection before stop() was called.";
                    return this._logger.log(e.Error, t), await this._stopPromise, Promise.reject(new Error(t))
                }
                if ("Connected" !== this._connectionState) {
                    const t = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
                    return this._logger.log(e.Error, t), Promise.reject(new Error(t))
                }
                this._connectionStarted = !0
            }
            send(t) {
                return "Connected" !== this._connectionState ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this._sendQueue || (this._sendQueue = new K(this.transport)), this._sendQueue.send(t))
            }
            async stop(t) {
                return "Disconnected" === this._connectionState ? (this._logger.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : "Disconnecting" === this._connectionState ? (this._logger.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = "Disconnecting", this._stopPromise = new Promise(t => {
                    this._stopPromiseResolver = t
                }), await this._stopInternal(t), void await this._stopPromise)
            }
            async _stopInternal(t) {
                this._stopError = t;
                try {
                    await this._startInternalPromise
                } catch (t) {}
                if (this.transport) {
                    try {
                        await this.transport.stop()
                    } catch (t) {
                        this._logger.log(e.Error, `HttpConnection.transport.stop() threw error '${t}'.`), this._stopConnection()
                    }
                    this.transport = void 0
                } else this._logger.log(e.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")
            }
            async _startInternal(t) {
                let o = this.baseUrl;
                this._accessTokenFactory = this._options.accessTokenFactory;
                try {
                    if (this._options.skipNegotiation) {
                        if (this._options.transport !== U.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                        this.transport = this._constructTransport(U.WebSockets), await this._startTransport(o, t)
                    } else {
                        let e = null,
                            n = 0;
                        do {
                            if (e = await this._getNegotiationResponse(o), "Disconnecting" === this._connectionState || "Disconnected" === this._connectionState) throw new Error("The connection was stopped during negotiation.");
                            if (e.error) throw new Error(e.error);
                            if (e.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                            if (e.url && (o = e.url), e.accessToken) {
                                const t = e.accessToken;
                                this._accessTokenFactory = () => t
                            }
                            n++
                        } while (e.url && n < 100);
                        if (100 === n && e.url) throw new Error("Negotiate redirection limit exceeded.");
                        await this._createTransport(o, this._options.transport, e, t)
                    }
                    this.transport instanceof B && (this.features.inherentKeepAlive = !0), "Connecting" === this._connectionState && (this._logger.log(e.Debug, "The HttpConnection connected successfully."), this._connectionState = "Connected")
                } catch (t) {
                    return this._logger.log(e.Error, "Failed to start the connection: " + t), this._connectionState = "Disconnected", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(t)
                }
            }
            async _getNegotiationResponse(t) {
                const o = {};
                if (this._accessTokenFactory) {
                    const t = await this._accessTokenFactory();
                    t && (o[O.Authorization] = "Bearer " + t)
                }
                const [r, s] = S();
                o[r] = s;
                const i = this._resolveNegotiateUrl(t);
                this._logger.log(e.Debug, `Sending negotiation request: ${i}.`);
                try {
                    const t = await this._httpClient.post(i, {
                        content: "",
                        headers: {
                            ...o,
                            ...this._options.headers
                        },
                        timeout: this._options.timeout,
                        withCredentials: this._options.withCredentials
                    });
                    if (200 !== t.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${t.statusCode}'`));
                    const e = JSON.parse(t.content);
                    return (!e.negotiateVersion || e.negotiateVersion < 1) && (e.connectionToken = e.connectionId), e
                } catch (t) {
                    let o = "Failed to complete negotiation with the server: " + t;
                    return t instanceof n && 404 === t.statusCode && (o += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this._logger.log(e.Error, o), Promise.reject(new l(o))
                }
            }
            _createConnectUrl(t, e) {
                return e ? t + (-1 === t.indexOf("?") ? "?" : "&") + "id=" + e : t
            }
            async _createTransport(t, o, n, r) {
                let s = this._createConnectUrl(t, n.connectionToken);
                if (this._isITransport(o)) return this._logger.log(e.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = o, await this._startTransport(s, r), void(this.connectionId = n.connectionId);
                const i = [],
                    c = n.availableTransports || [];
                let l = n;
                for (const n of c) {
                    const c = this._resolveTransportOrError(n, o, r);
                    if (c instanceof Error) i.push(n.transport + " failed:"), i.push(c);
                    else if (this._isITransport(c)) {
                        if (this.transport = c, !l) {
                            try {
                                l = await this._getNegotiationResponse(t)
                            } catch (t) {
                                return Promise.reject(t)
                            }
                            s = this._createConnectUrl(t, l.connectionToken)
                        }
                        try {
                            return await this._startTransport(s, r), void(this.connectionId = l.connectionId)
                        } catch (t) {
                            if (this._logger.log(e.Error, `Failed to start the transport '${n.transport}': ${t}`), l = void 0, i.push(new a(`${n.transport} failed: ${t}`, U[n.transport])), "Connecting" !== this._connectionState) {
                                const t = "Failed to select transport before stop() was called.";
                                return this._logger.log(e.Debug, t), Promise.reject(new Error(t))
                            }
                        }
                    }
                }
                return i.length > 0 ? Promise.reject(new h("Unable to connect to the server with any of the available transports. " + i.join(" "), i)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server."))
            }
            _constructTransport(t) {
                switch (t) {
                    case U.WebSockets:
                        if (!this._options.WebSocket) throw new Error("'WebSocket' is not supported in your environment.");
                        return new X(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {});
                    case U.ServerSentEvents:
                        if (!this._options.EventSource) throw new Error("'EventSource' is not supported in your environment.");
                        return new z(this._httpClient, this._accessTokenFactory, this._logger, this._options);
                    case U.LongPolling:
                        return new B(this._httpClient, this._accessTokenFactory, this._logger, this._options);
                    default:
                        throw new Error(`Unknown transport: ${t}.`)
                }
            }
            _startTransport(t, e) {
                return this.transport.onreceive = this.onreceive, this.transport.onclose = t => this._stopConnection(t), this.transport.connect(t, e)
            }
            _resolveTransportOrError(t, o, n) {
                const r = U[t.transport];
                if (null == r) return this._logger.log(e.Debug, `Skipping transport '${t.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${t.transport}' because it is not supported by this client.`);
                if (! function(t, e) {
                        return !t || 0 != (e & t)
                    }(o, r)) return this._logger.log(e.Debug, `Skipping transport '${U[r]}' because it was disabled by the client.`), new c(`'${U[r]}' is disabled by the client.`, r);
                if (!(t.transferFormats.map(t => q[t]).indexOf(n) >= 0)) return this._logger.log(e.Debug, `Skipping transport '${U[r]}' because it does not support the requested transfer format '${q[n]}'.`), new Error(`'${U[r]}' does not support ${q[n]}.`);
                if (r === U.WebSockets && !this._options.WebSocket || r === U.ServerSentEvents && !this._options.EventSource) return this._logger.log(e.Debug, `Skipping transport '${U[r]}' because it is not supported in your environment.'`), new i(`'${U[r]}' is not supported in your environment.`, r);
                this._logger.log(e.Debug, `Selecting transport '${U[r]}'.`);
                try {
                    return this._constructTransport(r)
                } catch (t) {
                    return t
                }
            }
            _isITransport(t) {
                return t && "object" == typeof t && "connect" in t
            }
            _stopConnection(t) {
                if (this._logger.log(e.Debug, `HttpConnection.stopConnection(${t}) called while in state ${this._connectionState}.`), this.transport = void 0, t = this._stopError || t, this._stopError = void 0, "Disconnected" !== this._connectionState) {
                    if ("Connecting" === this._connectionState) throw this._logger.log(e.Warning, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);
                    if ("Disconnecting" === this._connectionState && this._stopPromiseResolver(), t ? this._logger.log(e.Error, `Connection disconnected with error '${t}'.`) : this._logger.log(e.Information, "Connection disconnected."), this._sendQueue && (this._sendQueue.stop().catch(t => {
                            this._logger.log(e.Error, `TransportSendQueue.stop() threw error '${t}'.`)
                        }), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = "Disconnected", this._connectionStarted) {
                        this._connectionStarted = !1;
                        try {
                            this.onclose && this.onclose(t)
                        } catch (o) {
                            this._logger.log(e.Error, `HttpConnection.onclose(${t}) threw error '${o}'.`)
                        }
                    }
                } else this._logger.log(e.Debug, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`)
            }
            _resolveUrl(t) {
                if (0 === t.lastIndexOf("https://", 0) || 0 === t.lastIndexOf("http://", 0)) return t;
                if (!f.isBrowser) throw new Error(`Cannot resolve '${t}'.`);
                const o = window.document.createElement("a");
                return o.href = t, this._logger.log(e.Information, `Normalizing '${t}' to '${o.href}'.`), o.href
            }
            _resolveNegotiateUrl(t) {
                const e = t.indexOf("?");
                let o = t.substring(0, -1 === e ? t.length : e);
                return "/" !== o[o.length - 1] && (o += "/"), o += "negotiate", o += -1 === e ? "" : t.substring(e), -1 === o.indexOf("negotiateVersion") && (o += -1 === e ? "?" : "&", o += "negotiateVersion=" + this._negotiateVersion), o
            }
        }
        class K {
            constructor(t) {
                this._transport = t, this._buffer = [], this._executing = !0, this._sendBufferedData = new V, this._transportResult = new V, this._sendLoopPromise = this._sendLoop()
            }
            send(t) {
                return this._bufferData(t), this._transportResult || (this._transportResult = new V), this._transportResult.promise
            }
            stop() {
                return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise
            }
            _bufferData(t) {
                if (this._buffer.length && typeof this._buffer[0] != typeof t) throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof t}`);
                this._buffer.push(t), this._sendBufferedData.resolve()
            }
            async _sendLoop() {
                for (;;) {
                    if (await this._sendBufferedData.promise, !this._executing) {
                        this._transportResult && this._transportResult.reject("Connection stopped.");
                        break
                    }
                    this._sendBufferedData = new V;
                    const t = this._transportResult;
                    this._transportResult = void 0;
                    const e = "string" == typeof this._buffer[0] ? this._buffer.join("") : K._concatBuffers(this._buffer);
                    this._buffer.length = 0;
                    try {
                        await this._transport.send(e), t.resolve()
                    } catch (e) {
                        t.reject(e)
                    }
                }
            }
            static _concatBuffers(t) {
                const e = t.map(t => t.byteLength).reduce((t, e) => t + e),
                    o = new Uint8Array(e);
                let n = 0;
                for (const e of t) o.set(new Uint8Array(e), n), n += e.byteLength;
                return o.buffer
            }
        }
        class V {
            constructor() {
                this.promise = new Promise((t, e) => [this._resolver, this._rejecter] = [t, e])
            }
            resolve() {
                this._resolver()
            }
            reject(t) {
                this._rejecter(t)
            }
        }
        class Q {
            constructor() {
                this.name = "json", this.version = 1, this.transferFormat = q.Text
            }
            parseMessages(t, o) {
                if ("string" != typeof t) throw new Error("Invalid input for JSON hub protocol. Expected a string.");
                if (!t) return [];
                null === o && (o = d.instance);
                const n = x.parse(t),
                    r = [];
                for (const t of n) {
                    const n = JSON.parse(t);
                    if ("number" != typeof n.type) throw new Error("Invalid payload.");
                    switch (n.type) {
                        case A.Invocation:
                            this._isInvocationMessage(n);
                            break;
                        case A.StreamItem:
                            this._isStreamItemMessage(n);
                            break;
                        case A.Completion:
                            this._isCompletionMessage(n);
                            break;
                        case A.Ping:
                        case A.Close:
                            break;
                        default:
                            o.log(e.Information, "Unknown message type '" + n.type + "' ignored.");
                            continue
                    }
                    r.push(n)
                }
                return r
            }
            writeMessage(t) {
                return x.write(JSON.stringify(t))
            }
            _isInvocationMessage(t) {
                this._assertNotEmptyString(t.target, "Invalid payload for Invocation message."), void 0 !== t.invocationId && this._assertNotEmptyString(t.invocationId, "Invalid payload for Invocation message.")
            }
            _isStreamItemMessage(t) {
                if (this._assertNotEmptyString(t.invocationId, "Invalid payload for StreamItem message."), void 0 === t.item) throw new Error("Invalid payload for StreamItem message.")
            }
            _isCompletionMessage(t) {
                if (t.result && t.error) throw new Error("Invalid payload for Completion message.");
                !t.result && t.error && this._assertNotEmptyString(t.error, "Invalid payload for Completion message."), this._assertNotEmptyString(t.invocationId, "Invalid payload for Completion message.")
            }
            _assertNotEmptyString(t, e) {
                if ("string" != typeof t || "" === t) throw new Error(e)
            }
        }
        const G = {
            trace: e.Trace,
            debug: e.Debug,
            info: e.Information,
            information: e.Information,
            warn: e.Warning,
            warning: e.Warning,
            error: e.Error,
            critical: e.Critical,
            none: e.None
        };
        class Y {
            configureLogging(t) {
                if (_.isRequired(t, "logging"), void 0 !== t.log) this.logger = t;
                else if ("string" == typeof t) {
                    const e = function(t) {
                        const e = G[t.toLowerCase()];
                        if (void 0 !== e) return e;
                        throw new Error("Unknown log level: " + t)
                    }(t);
                    this.logger = new v(e)
                } else this.logger = new v(t);
                return this
            }
            withUrl(t, e) {
                return _.isRequired(t, "url"), _.isNotEmpty(t, "url"), this.url = t, this.httpConnectionOptions = "object" == typeof e ? {
                    ...this.httpConnectionOptions,
                    ...e
                } : {
                    ...this.httpConnectionOptions,
                    transport: e
                }, this
            }
            withHubProtocol(t) {
                return _.isRequired(t, "protocol"), this.protocol = t, this
            }
            withAutomaticReconnect(t) {
                if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set.");
                return t ? Array.isArray(t) ? this.reconnectPolicy = new L(t) : this.reconnectPolicy = t : this.reconnectPolicy = new L, this
            }
            build() {
                const t = this.httpConnectionOptions || {};
                if (void 0 === t.logger && (t.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
                const e = new J(this.url, t);
                return W.create(e, this.logger || d.instance, this.protocol || new Q, this.reconnectPolicy)
            }
        }
        return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", {
            value: Array.prototype.indexOf,
            writable: !0
        }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", {
            value: function(t, e) {
                return new Uint8Array(Array.prototype.slice.call(this, t, e))
            },
            writable: !0
        }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", {
            value: Array.prototype.forEach,
            writable: !0
        }), o
    })()
}));